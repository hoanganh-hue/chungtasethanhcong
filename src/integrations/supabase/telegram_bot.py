"""
Telegram Bot Integration for OpenManus-Youtu Integrated Framework
Bot for module communication and data persistence
"""

import asyncio
import logging
from typing import Dict, Any, List, Optional, Callable
from datetime import datetime, timedelta
import json
from dataclasses import dataclass
from telegram import Update, Bot, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, MessageHandler, CallbackQueryHandler,
    ContextTypes, filters, ConversationHandler
)
from telegram.constants import ParseMode
import httpx
from .client import SupabaseClient
from .models import (
    ModuleRequest, CCCDGenerationData, CCCDCheckData, TaxLookupData,
    DataAnalysisData, WebScrapingData, FormAutomationData,
    ReportGenerationData, ExcelExportData, TelegramUser, TelegramSession,
    ModuleType, RequestStatus
)

logger = logging.getLogger(__name__)


@dataclass
class TelegramConfig:
    """Telegram bot configuration."""
    bot_token: str
    webhook_url: Optional[str] = None
    webhook_port: int = 8443
    api_base_url: str = "http://localhost:8000"
    supabase_client: Optional[SupabaseClient] = None
    allowed_users: Optional[List[str]] = None
    admin_users: Optional[List[str]] = None


class TelegramBot:
    """Telegram bot for module communication."""
    
    def __init__(self, config: TelegramConfig):
        self.config = config
        self.bot: Optional[Bot] = None
        self.application: Optional[Application] = None
        self.supabase = config.supabase_client
        self.logger = logging.getLogger(f"{__name__}.TelegramBot")
        
        # Conversation states
        self.WAITING_FOR_MODULE = 1
        self.WAITING_FOR_PARAMS = 2
        self.WAITING_FOR_CONFIRMATION = 3
        
        # Module handlers
        self.module_handlers: Dict[str, Callable] = {
            ModuleType.CCCD_GENERATION.value: self._handle_cccd_generation,
            ModuleType.CCCD_CHECK.value: self._handle_cccd_check,
            ModuleType.TAX_LOOKUP.value: self._handle_tax_lookup,
            ModuleType.DATA_ANALYSIS.value: self._handle_data_analysis,
            ModuleType.WEB_SCRAPING.value: self._handle_web_scraping,
            ModuleType.FORM_AUTOMATION.value: self._handle_form_automation,
            ModuleType.REPORT_GENERATION.value: self._handle_report_generation,
            ModuleType.EXCEL_EXPORT.value: self._handle_excel_export
        }
    
    async def initialize(self) -> bool:
        """Initialize the Telegram bot."""
        try:
            self.logger.info("Initializing Telegram bot...")
            
            # Create bot instance
            self.bot = Bot(token=self.config.bot_token)
            
            # Create application
            self.application = Application.builder().bot(self.bot).build()
            
            # Add handlers
            self._add_handlers()
            
            # Test bot connection
            bot_info = await self.bot.get_me()
            self.logger.info(f"Bot initialized: @{bot_info.username}")
            
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to initialize Telegram bot: {e}")
            return False
    
    def _add_handlers(self):
        """Add command and message handlers."""
        # Start command
        self.application.add_handler(CommandHandler("start", self._start_command))
        
        # Help command
        self.application.add_handler(CommandHandler("help", self._help_command))
        
        # Status command
        self.application.add_handler(CommandHandler("status", self._status_command))
        
        # Modules command
        self.application.add_handler(CommandHandler("modules", self._modules_command))
        
        # Conversation handler for module operations
        conv_handler = ConversationHandler(
            entry_points=[CommandHandler("run", self._run_module_command)],
            states={
                self.WAITING_FOR_MODULE: [CallbackQueryHandler(self._select_module)],
                self.WAITING_FOR_PARAMS: [MessageHandler(filters.TEXT & ~filters.COMMAND, self._get_parameters)],
                self.WAITING_FOR_CONFIRMATION: [CallbackQueryHandler(self._confirm_execution)]
            },
            fallbacks=[CommandHandler("cancel", self._cancel_command)]
        )
        self.application.add_handler(conv_handler)
        
        # Callback query handler
        self.application.add_handler(CallbackQueryHandler(self._handle_callback))
        
        # Message handler for general messages
        self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self._handle_message))
    
    async def start_polling(self):
        """Start the bot in polling mode."""
        try:
            self.logger.info("Starting Telegram bot polling...")
            await self.application.initialize()
            await self.application.start()
            await self.application.updater.start_polling()
            
            # Keep the bot running
            await self.application.updater.idle()
            
        except Exception as e:
            self.logger.error(f"Error in polling: {e}")
        finally:
            await self.stop()
    
    async def start_webhook(self):
        """Start the bot with webhook."""
        try:
            self.logger.info("Starting Telegram bot webhook...")
            
            # Set webhook
            await self.bot.set_webhook(
                url=self.config.webhook_url,
                allowed_updates=["message", "callback_query"]
            )
            
            # Start application
            await self.application.initialize()
            await self.application.start()
            
            self.logger.info(f"Webhook set to: {self.config.webhook_url}")
            
        except Exception as e:
            self.logger.error(f"Failed to start webhook: {e}")
    
    async def stop(self):
        """Stop the bot."""
        try:
            if self.application:
                await self.application.stop()
                await self.application.shutdown()
            
            self.logger.info("Telegram bot stopped")
            
        except Exception as e:
            self.logger.error(f"Error stopping bot: {e}")
    
    async def _start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command."""
        user = update.effective_user
        chat_id = update.effective_chat.id
        
        # Register user in database
        await self._register_user(user)
        
        welcome_message = f"""
ü§ñ **Ch√†o m·ª´ng ƒë·∫øn v·ªõi OpenManus-Youtu Bot!**

Xin ch√†o {user.first_name}! T√¥i l√† bot h·ªó tr·ª£ c√°c t√≠nh nƒÉng:

üîß **C√°c module c√≥ s·∫µn:**
‚Ä¢ CCCD Generation - T·∫°o CCCD
‚Ä¢ CCCD Check - Ki·ªÉm tra CCCD  
‚Ä¢ Tax Lookup - Tra c·ª©u m√£ s·ªë thu·∫ø
‚Ä¢ Data Analysis - Ph√¢n t√≠ch d·ªØ li·ªáu
‚Ä¢ Web Scraping - Thu th·∫≠p d·ªØ li·ªáu web
‚Ä¢ Form Automation - T·ª± ƒë·ªông h√≥a form
‚Ä¢ Report Generation - T·∫°o b√°o c√°o
‚Ä¢ Excel Export - Xu·∫•t Excel

üìã **C√°c l·ªánh:**
/start - B·∫Øt ƒë·∫ßu
/help - Tr·ª£ gi√∫p
/modules - Xem modules
/run - Ch·∫°y module
/status - Tr·∫°ng th√°i h·ªá th·ªëng

S·ª≠ d·ª•ng /run ƒë·ªÉ b·∫Øt ƒë·∫ßu s·ª≠ d·ª•ng c√°c t√≠nh nƒÉng!
        """
        
        await update.message.reply_text(welcome_message, parse_mode=ParseMode.MARKDOWN)
    
    async def _help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /help command."""
        help_message = """
üìö **H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng OpenManus-Youtu Bot**

üîß **C√°c l·ªánh ch√≠nh:**
/start - Kh·ªüi ƒë·ªông bot
/help - Hi·ªÉn th·ªã tr·ª£ gi√∫p n√†y
/modules - Xem danh s√°ch modules
/run - Ch·∫°y m·ªôt module
/status - Ki·ªÉm tra tr·∫°ng th√°i h·ªá th·ªëng
/cancel - H·ªßy thao t√°c hi·ªán t·∫°i

üöÄ **C√°ch s·ª≠ d·ª•ng:**
1. S·ª≠ d·ª•ng /run ƒë·ªÉ ch·ªçn module
2. Nh·∫≠p tham s·ªë theo y√™u c·∫ßu
3. X√°c nh·∫≠n v√† ch·ªù k·∫øt qu·∫£
4. D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c l∆∞u t·ª± ƒë·ªông

üìä **Modules c√≥ s·∫µn:**
‚Ä¢ **CCCD Generation**: T·∫°o CCCD theo t·ªânh, gi·ªõi t√≠nh, nƒÉm sinh
‚Ä¢ **CCCD Check**: Ki·ªÉm tra th√¥ng tin CCCD
‚Ä¢ **Tax Lookup**: Tra c·ª©u m√£ s·ªë thu·∫ø
‚Ä¢ **Data Analysis**: Ph√¢n t√≠ch d·ªØ li·ªáu
‚Ä¢ **Web Scraping**: Thu th·∫≠p d·ªØ li·ªáu t·ª´ web
‚Ä¢ **Form Automation**: T·ª± ƒë·ªông ƒëi·ªÅn form
‚Ä¢ **Report Generation**: T·∫°o b√°o c√°o
‚Ä¢ **Excel Export**: Xu·∫•t d·ªØ li·ªáu ra Excel

‚ùì **H·ªó tr·ª£:** Li√™n h·ªá admin n·∫øu c·∫ßn tr·ª£ gi√∫p
        """
        
        await update.message.reply_text(help_message, parse_mode=ParseMode.MARKDOWN)
    
    async def _status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /status command."""
        try:
            # Check system status
            status_info = await self._get_system_status()
            
            status_message = f"""
üìä **Tr·∫°ng th√°i h·ªá th·ªëng**

üü¢ **Bot Status**: Ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng
üü¢ **Database**: {'K·∫øt n·ªëi' if self.supabase and self.supabase.connected else 'M·∫•t k·∫øt n·ªëi'}
üü¢ **API Server**: {'Ho·∫°t ƒë·ªông' if status_info.get('api_online') else 'Kh√¥ng ho·∫°t ƒë·ªông'}

üìà **Th·ªëng k√™:**
‚Ä¢ T·ªïng requests: {status_info.get('total_requests', 0)}
‚Ä¢ Requests h√¥m nay: {status_info.get('today_requests', 0)}
‚Ä¢ Modules ho·∫°t ƒë·ªông: {len(self.module_handlers)}

üïê **Th·ªùi gian**: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}
            """
            
            await update.message.reply_text(status_message, parse_mode=ParseMode.MARKDOWN)
            
        except Exception as e:
            self.logger.error(f"Error getting status: {e}")
            await update.message.reply_text("‚ùå L·ªói khi l·∫•y tr·∫°ng th√°i h·ªá th·ªëng")
    
    async def _modules_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /modules command."""
        modules_message = """
üîß **Danh s√°ch Modules**

1Ô∏è‚É£ **CCCD Generation**
   - T·∫°o CCCD theo t·ªânh, gi·ªõi t√≠nh, nƒÉm sinh
   - Tham s·ªë: province, gender, birth_year_range, quantity

2Ô∏è‚É£ **CCCD Check** 
   - Ki·ªÉm tra th√¥ng tin CCCD
   - Tham s·ªë: cccd_number

3Ô∏è‚É£ **Tax Lookup**
   - Tra c·ª©u m√£ s·ªë thu·∫ø
   - Tham s·ªë: tax_code

4Ô∏è‚É£ **Data Analysis**
   - Ph√¢n t√≠ch d·ªØ li·ªáu
   - Tham s·ªë: analysis_type, input_data

5Ô∏è‚É£ **Web Scraping**
   - Thu th·∫≠p d·ªØ li·ªáu t·ª´ web
   - Tham s·ªë: target_url, scraping_config

6Ô∏è‚É£ **Form Automation**
   - T·ª± ƒë·ªông ƒëi·ªÅn form
   - Tham s·ªë: form_url, form_data

7Ô∏è‚É£ **Report Generation**
   - T·∫°o b√°o c√°o
   - Tham s·ªë: report_type, report_data

8Ô∏è‚É£ **Excel Export**
   - Xu·∫•t d·ªØ li·ªáu ra Excel
   - Tham s·ªë: export_data

S·ª≠ d·ª•ng /run ƒë·ªÉ ch·ªçn v√† ch·∫°y module!
        """
        
        await update.message.reply_text(modules_message, parse_mode=ParseMode.MARKDOWN)
    
    async def _run_module_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /run command - start module selection."""
        keyboard = [
            [InlineKeyboardButton("1Ô∏è‚É£ CCCD Generation", callback_data="module_cccd_generation")],
            [InlineKeyboardButton("2Ô∏è‚É£ CCCD Check", callback_data="module_cccd_check")],
            [InlineKeyboardButton("3Ô∏è‚É£ Tax Lookup", callback_data="module_tax_lookup")],
            [InlineKeyboardButton("4Ô∏è‚É£ Data Analysis", callback_data="module_data_analysis")],
            [InlineKeyboardButton("5Ô∏è‚É£ Web Scraping", callback_data="module_web_scraping")],
            [InlineKeyboardButton("6Ô∏è‚É£ Form Automation", callback_data="module_form_automation")],
            [InlineKeyboardButton("7Ô∏è‚É£ Report Generation", callback_data="module_report_generation")],
            [InlineKeyboardButton("8Ô∏è‚É£ Excel Export", callback_data="module_excel_export")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            "üîß **Ch·ªçn module ƒë·ªÉ ch·∫°y:**",
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN
        )
        
        return self.WAITING_FOR_MODULE
    
    async def _select_module(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle module selection."""
        query = update.callback_query
        await query.answer()
        
        module_type = query.data.replace("module_", "")
        context.user_data['selected_module'] = module_type
        
        # Get module parameters info
        params_info = self._get_module_parameters(module_type)
        
        await query.edit_message_text(
            f"üìã **Module: {module_type.replace('_', ' ').title()}**\n\n"
            f"Tham s·ªë c·∫ßn thi·∫øt:\n{params_info}\n\n"
            f"Vui l√≤ng nh·∫≠p tham s·ªë theo ƒë·ªãnh d·∫°ng JSON:",
            parse_mode=ParseMode.MARKDOWN
        )
        
        return self.WAITING_FOR_PARAMS
    
    async def _get_parameters(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Get module parameters from user."""
        try:
            parameters_text = update.message.text
            parameters = json.loads(parameters_text)
            
            context.user_data['parameters'] = parameters
            
            # Show confirmation
            confirmation_text = f"""
‚úÖ **X√°c nh·∫≠n th·ª±c thi**

üîß **Module**: {context.user_data['selected_module'].replace('_', ' ').title()}
üìã **Tham s·ªë**: 
```json
{json.dumps(parameters, indent=2, ensure_ascii=False)}
```

B·∫°n c√≥ mu·ªën ti·∫øp t·ª•c?
            """
            
            keyboard = [
                [InlineKeyboardButton("‚úÖ X√°c nh·∫≠n", callback_data="confirm_yes")],
                [InlineKeyboardButton("‚ùå H·ªßy", callback_data="confirm_no")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.message.reply_text(
                confirmation_text,
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN
            )
            
            return self.WAITING_FOR_CONFIRMATION
            
        except json.JSONDecodeError:
            await update.message.reply_text(
                "‚ùå **L·ªói ƒë·ªãnh d·∫°ng JSON!**\n\n"
                "Vui l√≤ng nh·∫≠p tham s·ªë theo ƒë·ªãnh d·∫°ng JSON h·ª£p l·ªá.\n"
                "V√≠ d·ª•:\n"
                "```json\n"
                '{"province": "H∆∞ng Y√™n", "gender": "n·ªØ", "quantity": 100}\n'
                "```",
                parse_mode=ParseMode.MARKDOWN
            )
            return self.WAITING_FOR_PARAMS
        except Exception as e:
            self.logger.error(f"Error parsing parameters: {e}")
            await update.message.reply_text("‚ùå L·ªói khi x·ª≠ l√Ω tham s·ªë")
            return ConversationHandler.END
    
    async def _confirm_execution(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle execution confirmation."""
        query = update.callback_query
        await query.answer()
        
        if query.data == "confirm_yes":
            # Execute module
            await self._execute_module(update, context)
        else:
            await query.edit_message_text("‚ùå ƒê√£ h·ªßy thao t√°c")
        
        return ConversationHandler.END
    
    async def _execute_module(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Execute the selected module."""
        query = update.callback_query
        module_type = context.user_data['selected_module']
        parameters = context.user_data['parameters']
        
        try:
            # Update message to show processing
            await query.edit_message_text(
                f"‚è≥ **ƒêang x·ª≠ l√Ω...**\n\n"
                f"Module: {module_type.replace('_', ' ').title()}\n"
                f"Vui l√≤ng ch·ªù trong gi√¢y l√°t...",
                parse_mode=ParseMode.MARKDOWN
            )
            
            # Create module request
            request = await self._create_module_request(
                module_type=module_type,
                user_id=str(update.effective_user.id),
                chat_id=str(update.effective_chat.id),
                request_data=parameters
            )
            
            # Execute module
            result = await self._call_module_api(module_type, parameters)
            
            # Save result to database
            await self._save_module_result(module_type, request.id, result)
            
            # Send result to user
            await self._send_result_to_user(update, module_type, result)
            
        except Exception as e:
            self.logger.error(f"Error executing module {module_type}: {e}")
            await query.edit_message_text(
                f"‚ùå **L·ªói khi th·ª±c thi module**\n\n"
                f"Module: {module_type.replace('_', ' ').title()}\n"
                f"L·ªói: {str(e)}",
                parse_mode=ParseMode.MARKDOWN
            )
    
    async def _handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle callback queries."""
        query = update.callback_query
        await query.answer()
    
    async def _handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle general messages."""
        await update.message.reply_text(
            "ü§ñ S·ª≠ d·ª•ng /help ƒë·ªÉ xem h∆∞·ªõng d·∫´n ho·∫∑c /run ƒë·ªÉ ch·∫°y module!"
        )
    
    async def _cancel_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /cancel command."""
        await update.message.reply_text("‚ùå ƒê√£ h·ªßy thao t√°c")
        return ConversationHandler.END
    
    # Module handlers
    async def _handle_cccd_generation(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Handle CCCD generation module."""
        # Implementation for CCCD generation
        return {"status": "success", "message": "CCCD generation completed"}
    
    async def _handle_cccd_check(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Handle CCCD check module."""
        # Implementation for CCCD check
        return {"status": "success", "message": "CCCD check completed"}
    
    async def _handle_tax_lookup(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Handle tax lookup module."""
        # Implementation for tax lookup
        return {"status": "success", "message": "Tax lookup completed"}
    
    async def _handle_data_analysis(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Handle data analysis module."""
        # Implementation for data analysis
        return {"status": "success", "message": "Data analysis completed"}
    
    async def _handle_web_scraping(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Handle web scraping module."""
        # Implementation for web scraping
        return {"status": "success", "message": "Web scraping completed"}
    
    async def _handle_form_automation(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Handle form automation module."""
        # Implementation for form automation
        return {"status": "success", "message": "Form automation completed"}
    
    async def _handle_report_generation(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Handle report generation module."""
        # Implementation for report generation
        return {"status": "success", "message": "Report generation completed"}
    
    async def _handle_excel_export(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Handle Excel export module."""
        # Implementation for Excel export
        return {"status": "success", "message": "Excel export completed"}
    
    # Helper methods
    async def _register_user(self, user):
        """Register user in database."""
        if not self.supabase:
            return
        
        try:
            user_data = {
                "telegram_id": str(user.id),
                "username": user.username,
                "first_name": user.first_name,
                "last_name": user.last_name,
                "is_bot": user.is_bot,
                "language_code": user.language_code,
                "last_activity": datetime.utcnow().isoformat()
            }
            
            # Check if user exists
            existing = await self.supabase.select_data(
                "telegram_users",
                filters={"telegram_id": str(user.id)}
            )
            
            if existing:
                # Update existing user
                await self.supabase.update_data(
                    "telegram_users",
                    user_data,
                    {"telegram_id": str(user.id)}
                )
            else:
                # Insert new user
                await self.supabase.insert_data("telegram_users", user_data)
                
        except Exception as e:
            self.logger.error(f"Error registering user: {e}")
    
    async def _create_module_request(self, module_type: str, user_id: str, 
                                   chat_id: str, request_data: Dict[str, Any]) -> ModuleRequest:
        """Create module request in database."""
        if not self.supabase:
            raise Exception("Supabase client not available")
        
        request_data_dict = {
            "module_type": module_type,
            "user_id": user_id,
            "telegram_chat_id": chat_id,
            "request_data": request_data,
            "status": RequestStatus.PENDING.value
        }
        
        result = await self.supabase.insert_data("module_requests", request_data_dict)
        
        return ModuleRequest.from_dict(result)
    
    async def _call_module_api(self, module_type: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Call module API."""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.config.api_base_url}/modules/{module_type}/execute",
                    json=parameters,
                    timeout=300.0
                )
                
                if response.status_code == 200:
                    return response.json()
                else:
                    raise Exception(f"API error: {response.status_code}")
                    
        except Exception as e:
            self.logger.error(f"Error calling module API: {e}")
            raise
    
    async def _save_module_result(self, module_type: str, request_id: str, result: Dict[str, Any]):
        """Save module result to appropriate table."""
        if not self.supabase:
            return
        
        try:
            # Map module type to table name
            table_mapping = {
                ModuleType.CCCD_GENERATION.value: "cccd_generation_data",
                ModuleType.CCCD_CHECK.value: "cccd_check_data",
                ModuleType.TAX_LOOKUP.value: "tax_lookup_data",
                ModuleType.DATA_ANALYSIS.value: "data_analysis_data",
                ModuleType.WEB_SCRAPING.value: "web_scraping_data",
                ModuleType.FORM_AUTOMATION.value: "form_automation_data",
                ModuleType.REPORT_GENERATION.value: "report_generation_data",
                ModuleType.EXCEL_EXPORT.value: "excel_export_data"
            }
            
            table_name = table_mapping.get(module_type)
            if not table_name:
                self.logger.warning(f"No table mapping for module type: {module_type}")
                return
            
            # Prepare data for specific table
            data = {
                "request_id": request_id,
                "success": result.get("status") == "success",
                "error_message": result.get("error") if result.get("status") != "success" else None
            }
            
            # Add module-specific fields
            if module_type == ModuleType.CCCD_GENERATION.value:
                data.update({
                    "province": result.get("province", ""),
                    "gender": result.get("gender", ""),
                    "birth_year_range": result.get("birth_year_range", ""),
                    "quantity": result.get("quantity", 0),
                    "generated_cccds": result.get("generated_cccds", []),
                    "generation_time": result.get("processing_time", 0),
                    "success_count": result.get("success_count", 0),
                    "failure_count": result.get("failure_count", 0)
                })
            elif module_type == ModuleType.CCCD_CHECK.value:
                data.update({
                    "cccd_number": result.get("cccd_number", ""),
                    "check_result": result.get("check_result", {}),
                    "check_time": result.get("processing_time", 0)
                })
            # Add more module-specific mappings as needed
            
            await self.supabase.insert_data(table_name, data)
            
        except Exception as e:
            self.logger.error(f"Error saving module result: {e}")
    
    async def _send_result_to_user(self, update: Update, module_type: str, result: Dict[str, Any]):
        """Send result to user."""
        try:
            if result.get("status") == "success":
                message = f"""
‚úÖ **Ho√†n th√†nh th√†nh c√¥ng!**

üîß **Module**: {module_type.replace('_', ' ').title()}
üìä **K·∫øt qu·∫£**: {result.get('message', 'Th√†nh c√¥ng')}

üìã **Chi ti·∫øt**:
```json
{json.dumps(result, indent=2, ensure_ascii=False)}
```

üíæ **D·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o c∆° s·ªü d·ªØ li·ªáu**
                """
            else:
                message = f"""
‚ùå **L·ªói khi th·ª±c thi**

üîß **Module**: {module_type.replace('_', ' ').title()}
üö´ **L·ªói**: {result.get('error', 'L·ªói kh√¥ng x√°c ƒë·ªãnh')}
                """
            
            await update.callback_query.edit_message_text(
                message,
                parse_mode=ParseMode.MARKDOWN
            )
            
        except Exception as e:
            self.logger.error(f"Error sending result to user: {e}")
    
    def _get_module_parameters(self, module_type: str) -> str:
        """Get module parameters description."""
        parameters = {
            ModuleType.CCCD_GENERATION.value: """
‚Ä¢ province: T·ªânh (string)
‚Ä¢ gender: Gi·ªõi t√≠nh (string) 
‚Ä¢ birth_year_range: Kho·∫£ng nƒÉm sinh (string)
‚Ä¢ quantity: S·ªë l∆∞·ª£ng (integer)
            """,
            ModuleType.CCCD_CHECK.value: """
‚Ä¢ cccd_number: S·ªë CCCD (string)
            """,
            ModuleType.TAX_LOOKUP.value: """
‚Ä¢ tax_code: M√£ s·ªë thu·∫ø (string)
            """,
            ModuleType.DATA_ANALYSIS.value: """
‚Ä¢ analysis_type: Lo·∫°i ph√¢n t√≠ch (string)
‚Ä¢ input_data: D·ªØ li·ªáu ƒë·∫ßu v√†o (object)
            """,
            ModuleType.WEB_SCRAPING.value: """
‚Ä¢ target_url: URL ƒë√≠ch (string)
‚Ä¢ scraping_config: C·∫•u h√¨nh scraping (object)
            """,
            ModuleType.FORM_AUTOMATION.value: """
‚Ä¢ form_url: URL form (string)
‚Ä¢ form_data: D·ªØ li·ªáu form (object)
            """,
            ModuleType.REPORT_GENERATION.value: """
‚Ä¢ report_type: Lo·∫°i b√°o c√°o (string)
‚Ä¢ report_data: D·ªØ li·ªáu b√°o c√°o (object)
            """,
            ModuleType.EXCEL_EXPORT.value: """
‚Ä¢ export_data: D·ªØ li·ªáu xu·∫•t (object)
            """
        }
        
        return parameters.get(module_type, "Kh√¥ng c√≥ th√¥ng tin tham s·ªë")
    
    async def _get_system_status(self) -> Dict[str, Any]:
        """Get system status."""
        try:
            # Check API server
            async with httpx.AsyncClient() as client:
                try:
                    response = await client.get(f"{self.config.api_base_url}/health", timeout=5.0)
                    api_online = response.status_code == 200
                except:
                    api_online = False
            
            # Get database stats
            total_requests = 0
            today_requests = 0
            
            if self.supabase and self.supabase.connected:
                try:
                    requests = await self.supabase.select_data("module_requests")
                    total_requests = len(requests)
                    
                    today = datetime.now().date()
                    today_requests = len([
                        r for r in requests 
                        if datetime.fromisoformat(r['created_at']).date() == today
                    ])
                except:
                    pass
            
            return {
                "api_online": api_online,
                "total_requests": total_requests,
                "today_requests": today_requests
            }
            
        except Exception as e:
            self.logger.error(f"Error getting system status: {e}")
            return {
                "api_online": False,
                "total_requests": 0,
                "today_requests": 0
            }